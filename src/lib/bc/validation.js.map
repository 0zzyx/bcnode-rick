{"version":3,"sources":["../../src/bc/validation.es6"],"names":["isValidBlock","isValidChildAge","isValidBlockCached","getNewestHeader","blockchainHeadersAreChain","validateRoveredSequences","validateSequenceTotalDistance","validateSequenceDifficulty","validateBlockSequence","childrenHighestBlock","childrenHeightSum","inspect","require","BN","all","aperture","equals","flatten","fromPairs","head","identity","last","reject","sort","sum","getLogger","blake2bl","concatAll","BcBlock","BlockchainHeader","Block","getExpFactorDiff","getNewBlockCount","getDiff","getChildrenBlocksHashes","getChildrenRootHash","blockchainMapToList","createMerkleRoot","prepareWork","distance","GENESIS_DATA","FINGERPRINTS_TEMPLATE","MINIMAL_DIFFICULTY","DF_CONFIG","blockchainHeaders","map","name","dfNumerator","dfDenominator","dfVoid","dfBound","logger","__filename","newBlock","type","undefined","getHeight","lt","numberOfBlockchainsNeededMatchesChildBlock","warn","ifMoreThanOneHeaderPerBlockchainAreTheyOrdered","isChainRootCorrectlyCalculated","isFieldLengthBounded","isMerkleRootCorrectlyCalculated","isDistanceAboveDifficulty","isDistanceCorrectlyCalculated","newestHeader","info","bcBlockTimestamp","getTimestamp","mul","toNumber","highRangeLimit","lowRangeLimit","newestHeaderDFBound","blockchain","newestHeaderTimestamp","timestamp","add","upperTimestampLimit","lowerTimestampLimit","sub","gt","persistence","Promise","resolve","cached","get","getHash","_","valid","put","String","err","error","headers","getBlockchainHeaders","toObject","Object","keys","reduce","newest","key","sorted","a","b","header","pop","debug","hash","headerValues","values","depth","headerValuesWithLengthGtZero","filter","headersList","length","childBlockchainCount","headersMap","chainsConditions","listName","getMethodName","toUpperCase","slice","chainHeaders","orderingCorrect","toString","receivedChainRoot","getChainRoot","expectedBlockHashes","expectedChainRoot","k","areDarkFibersValid","newBlockTimestampMs","blockchainHeadersList","dfBoundHeadersChecks","getBlockchain","dfVoidHeadersChecks","receivedMerkleRoot","getMerkleRoot","blockHashes","expectedMerkleRoot","getTxsList","getDifficulty","getMiner","getVersion","getSchemaVersion","getNrgGrant","blockchainFingerprintsRoot","receivedDistance","getDistance","recievedDifficulty","expectedWork","getPreviousHash","expectedDistance","getNonce","childHeaderList","parentHeaderList","block","firstChildHeader","lastParentHeader","nonEmpty","check","result","blocks","sortedBlocks","checks","child","parent","height","validateChildHeadersSequence","previousBlock","chainWeight","divRound","finalDistance","getTotalDistance","newBlockCount","preExpDiff","finalDifficulty","childBlock","parentBlock","childBlockchainHeaders","parentBlockchainHeaders","getBtcList","getEthList","getLskList","getNeoList","getWavList","sortedBlocksTopDown","validPairs","validDifficulties","pairs","heights","JSON","stringify","validPairSubchains","highest","top","set","Number"],"mappings":";;;;;QAqDgBA,Y,GAAAA,Y;QAmDAC,e,GAAAA,e;QAqCMC,kB,GAAAA,kB;QAsBNC,e,GAAAA,e;QAoLAC,yB,GAAAA,yB;QA+CAC,wB,GAAAA,wB;QAWAC,6B,GAAAA,6B;QAoBAC,0B,GAAAA,0B;QAgDAC,qB,GAAAA,qB;QAwDAC,oB,GAAAA,oB;QA2BAC,iB,GAAAA,iB;AAxiBhB;;;;;;;;AAQA;AACA,MAAM,EAAEC,OAAF,KAAcC,QAAQ,MAAR,CAApB;AACA,MAAMC,KAAKD,QAAQ,OAAR,CAAX;AACA,MAAM;AACJE,KADI;AAEJC,UAFI;AAGJC,QAHI;AAIJC,SAJI;AAKJC,WALI;AAMJC,MANI;AAOJC,UAPI;AAQJC,MARI;AASJC,QATI;AAUJC,MAVI;AAWJC;AAXI,IAYFZ,QAAQ,OAAR,CAZJ;;AAcA,MAAM,EAAEa,SAAF,KAAgBb,QAAQ,WAAR,CAAtB;AACA,MAAM,EAAEc,QAAF,KAAed,QAAQ,iBAAR,CAArB;AACA,MAAM,EAAEe,SAAF,KAAgBf,QAAQ,gBAAR,CAAtB;AACA,MAAM,EAAEgB,OAAF,EAAWC,gBAAX,EAA6BC,KAA7B,KAAuClB,QAAQ,mBAAR,CAA7C;AACA,MAAM;AACJmB,kBADI;AAEJC,kBAFI;AAGJC,SAHI;AAIJC,yBAJI;AAKJC,qBALI;AAMJC,qBANI;AAOJC,kBAPI;AAQJC,aARI;AASJC;AATI,IAUF3B,QAAQ,sBAAR,CAVJ;AAWA,MAAM4B,eAAe5B,QAAQ,eAAR,CAArB;AACA,MAAM6B,wBAAwB7B,QAAQ,iDAAR,CAA9B;AACA,MAAM8B,qBAAqB,IAAI7B,EAAJ,CAAO,eAAP,CAA3B;;AAKO,MAAM8B,gCAAsBzB,UAAUuB,sBAAsBG,iBAAtB,CAAwCC,GAAxC,CAC3C,CAAC,EAACC,IAAD,EAAOC,WAAP,EAAoBC,aAApB,EAAmCC,MAAnC,EAA2CC,OAA3C,EAAD,KAA0D,CAACJ,IAAD,EAAO,EAACC,WAAD,EAAcC,aAAd,EAA6BC,MAA7B,EAAqCC,OAArC,EAAP,CADf,CAAV,CAA5B;;AAIP,MAAMC,SAAS1B,UAAU2B,UAAV,CAAf;;AAEO,SAASpD,YAAT,CAAuBqD,QAAvB,EAA0CC,OAAe,CAAzD,EAAkE;AACvE,MAAID,aAAaE,SAAjB,EAA4B;AAC1B,WAAO,KAAP;AACD;AACD,MAAI,IAAI1C,EAAJ,CAAOwC,SAASG,SAAT,EAAP,EAA6BC,EAA7B,CAAgC,IAAI5C,EAAJ,CAAO,MAAP,CAAhC,MAAoD,IAAxD,EAA8D;AAC5D,WAAO,IAAP;AACD;AACD;AACA;AACA;AACA;AACA,MAAI,CAAC6C,2CAA2CL,QAA3C,CAAL,EAA2D;AACzDF,WAAOQ,IAAP,CAAY,oDAAZ;AACA,WAAO,KAAP;AACD;AACD,MAAI,CAACC,+CAA+CP,QAA/C,CAAL,EAA+D;AAC7DF,WAAOQ,IAAP,CAAY,wDAAZ;AACA,WAAO,KAAP;AACD;AACD,MAAI,CAACE,+BAA+BR,QAA/B,CAAL,EAA+C;AAC7CF,WAAOQ,IAAP,CAAY,wCAAZ;AACA,WAAO,KAAP;AACD;AACD,MAAI,CAACG,qBAAqBT,QAArB,CAAL,EAAqC;AACnCF,WAAOQ,IAAP,CAAY,8BAAZ;AACA,WAAO,KAAP;AACD;AACD,MAAI,CAACI,gCAAgCV,QAAhC,CAAL,EAAgD;AAC9CF,WAAOQ,IAAP,CAAY,yCAAZ;AACA,WAAO,KAAP;AACD;AACD,MAAI,CAAC1D,gBAAgBoD,QAAhB,CAAL,EAAgC;AAC9B,WAAO,KAAP;AACD;AACD,MAAI,CAACW,0BAA0BX,QAA1B,CAAL,EAA0C;AACxCF,WAAOQ,IAAP,CAAY,mCAAZ;AACA,WAAO,KAAP;AACD;AACD,MAAI,CAACM,8BAA8BZ,QAA9B,CAAL,EAA8C;AAC5CF,WAAOQ,IAAP,CAAY,uCAAZ;AACA,WAAO,KAAP;AACD;AACD,MAAIL,SAAS,CAAb,EAAgB;AACd;AACA;AACA;AACA;AACD;AACD,SAAO,IAAP;AACD;;AAEM,SAASrD,eAAT,CAA0BoD,QAA1B,EAA6CC,OAAe,CAA5D,EAAqE;AAC1E,QAAMY,eAAe/D,gBAAgBkD,QAAhB,CAArB;;AAEAF,SAAOgB,IAAP,CAAY,2CAAZ;AACA,MAAID,iBAAiB,KAArB,EAA4B;AAC1Bf,WAAOQ,IAAP,CAAY,yDAAZ;AACA,WAAO,KAAP;AACD;;AAED;AACA,QAAMS,mBAAmB,IAAIvD,EAAJ,CAAOwC,SAASgB,YAAT,EAAP,EAAgCC,GAAhC,CAAoC,IAAIzD,EAAJ,CAAO,IAAP,CAApC,EAAkD0D,QAAlD,EAAzB;AACA,QAAMC,iBAAiB,KAAK,IAA5B;AACA,QAAMC,gBAAgB,KAAK,IAA3B;AACA,QAAMC,sBAAsB/B,UAAUuB,aAAaS,UAAvB,EAAmCzB,OAAnC,GAA6C,IAAzE;AACA,QAAM0B,wBAAwB,IAAI/D,EAAJ,CAAOqD,aAAaW,SAApB,EAA+BC,GAA/B,CAAmC,IAAIjE,EAAJ,CAAO6D,mBAAP,CAAnC,EAAgEH,QAAhE,EAA9B;AACA,QAAMQ,sBAAsB,IAAIlE,EAAJ,CAAO+D,qBAAP,EAA8BE,GAA9B,CAAkC,IAAIjE,EAAJ,CAAO2D,cAAP,CAAlC,EAA0DD,QAA1D,EAA5B;AACA,QAAMS,sBAAsB,IAAInE,EAAJ,CAAO+D,qBAAP,EAA8BK,GAA9B,CAAkC,IAAIpE,EAAJ,CAAO4D,aAAP,CAAlC,EAAyDF,QAAzD,EAA5B;;AAEApB,SAAOgB,IAAP,CAAY,iCAAiCC,gBAA7C;AACAjB,SAAOgB,IAAP,CAAY,0BAA0BO,mBAAtC;AACAvB,SAAOgB,IAAP,CAAY,8BAA8BD,aAAaW,SAAvD;AACA1B,SAAOgB,IAAP,CAAY,0BAA0BY,mBAAtC;AACA5B,SAAOgB,IAAP,CAAY,0BAA0Ba,mBAAtC;;AAEA;AACA,MAAI,IAAInE,EAAJ,CAAOuD,gBAAP,EAAyBc,EAAzB,CAA4B,IAAIrE,EAAJ,CAAOkE,mBAAP,CAA5B,MAA6D,IAAjE,EAAuE;AACrE5B,WAAOQ,IAAP,CAAY,qCAAZ;AACA,WAAO,KAAP;AACD;;AAED,MAAI,IAAI9C,EAAJ,CAAOuD,gBAAP,EAAyBX,EAAzB,CAA4B,IAAI5C,EAAJ,CAAOmE,mBAAP,CAA5B,MAA6D,IAAjE,EAAuE;AACrE7B,WAAOQ,IAAP,CAAY,qCAAZ;AACA,WAAO,KAAP;AACD;AACD,SAAO,IAAP;AACD;;AAEM,eAAezD,kBAAf,CAAmCiF,WAAnC,EAAwD9B,QAAxD,EAA2EC,OAAe,CAA1F,EAA+G;AACpH,MAAI;AACF,QAAI,IAAIzC,EAAJ,CAAOwC,SAASG,SAAT,EAAP,EAA6BC,EAA7B,CAAgC,IAAI5C,EAAJ,CAAO,MAAP,CAAhC,MAAoD,IAAxD,EAA8D;AAC5D,aAAOuE,QAAQC,OAAR,CAAgB,IAAhB,CAAP;AACD;AACD,UAAMC,SAAS,MAAMH,YAAYI,GAAZ,CAAgB,WAAWlC,SAASmC,OAAT,EAA3B,CAArB;AACA;AACA,WAAOJ,QAAQC,OAAR,CAAgBC,WAAW,MAA3B,CAAP;AACD,GAPD,CAOE,OAAOG,CAAP,EAAU;AACV,QAAI;AACF,YAAMC,QAAQ1F,aAAaqD,QAAb,EAAuBC,IAAvB,CAAd;AACA,YAAM6B,YAAYQ,GAAZ,CAAgB,WAAWtC,SAASmC,OAAT,EAA3B,EAA+CI,OAAOF,KAAP,CAA/C,CAAN;AACA;AACA,aAAON,QAAQC,OAAR,CAAgBK,KAAhB,CAAP;AACD,KALD,CAKE,OAAOG,GAAP,EAAY;AACZ;AACA1C,aAAO2C,KAAP,CAAaD,GAAb;AACA,aAAOT,QAAQC,OAAR,CAAgB,KAAhB,CAAP;AACD;AACF;AACF;;AAEM,SAASlF,eAAT,CAA0BkD,QAA1B,EAAmD;AACxDF,SAAOgB,IAAP,CAAY,0BAA0Bd,SAASG,SAAT,EAAtC;AACA,MAAIH,aAAaE,SAAjB,EAA4B;AAC1BJ,WAAOQ,IAAP,CAAY,sDAAZ;AACA,WAAO,KAAP;AACD;;AAED,QAAMoC,UAAU1C,SAAS2C,oBAAT,GAAgCC,QAAhC,EAAhB;AACA,QAAM/B,eAAegC,OAAOC,IAAP,CAAYJ,OAAZ,EAAqBK,MAArB,CAA4B,CAACC,MAAD,EAASC,GAAT,KAAiB;AAChE,UAAMC,SAASR,QAAQO,GAAR,EAAa/E,IAAb,CAAkB,CAACiF,CAAD,EAAIC,CAAJ,KAAU;AACzC;AACA,UAAI,IAAI5F,EAAJ,CAAO2F,EAAE3B,SAAT,EAAoBK,EAApB,CAAuB,IAAIrE,EAAJ,CAAO4F,EAAE5B,SAAT,CAAvB,MAAgD,IAApD,EAA0D;AACxD,eAAO,CAAP;AACD;AACD,UAAI,IAAIhE,EAAJ,CAAO2F,EAAE3B,SAAT,EAAoBpB,EAApB,CAAuB,IAAI5C,EAAJ,CAAO4F,EAAE5B,SAAT,CAAvB,MAAgD,IAApD,EAA0D;AACxD,eAAO,CAAC,CAAR;AACD;AACD,aAAO,CAAP;AACD,KATc,CAAf;;AAWA,UAAM6B,SAASH,OAAOI,GAAP,EAAf;;AAEA,QAAIN,WAAW,KAAf,EAAsB;AACpBA,eAASK,MAAT;AACD,KAFD,MAEO;AACL,UAAI,IAAI7F,EAAJ,CAAOwF,OAAOxB,SAAd,EAAyBpB,EAAzB,CAA4B,IAAI5C,EAAJ,CAAO6F,OAAO7B,SAAd,CAA5B,CAAJ,EAA2D;AACzDwB,iBAASK,MAAT;AACD;AACF;AACD,WAAOL,MAAP;AACD,GAtBoB,EAsBlB,KAtBkB,CAArB;;AAwBA,MAAInC,iBAAiB,KAArB,EAA4B;AAC1B,WAAO,KAAP;AACD;;AAED,SAAOA,YAAP;AACD;;AAED;AACA;AACA;AACA;;AAEA,SAASR,0CAAT,CAAqDL,QAArD,EAA8E;AAC5EF,SAAOyD,KAAP,CAAa,+DAAb;AACA;AACA,MAAIvD,SAASG,SAAT,OAAyBhB,aAAaqE,IAAtC,IAA8CxD,SAASG,SAAT,OAAyB,CAA3E,EAA8E;AAC5E,WAAO,IAAP;AACD;AACD;AACA,QAAMsD,eAAeZ,OAAOa,MAAP,CAAc1D,SAAS2C,oBAAT,GAAgCC,QAAhC,EAAd,CAArB;AACA9C,SAAOyD,KAAP,CAAajG,QAAQmG,YAAR,EAAsB,EAACE,OAAO,CAAR,EAAtB,CAAb;AACA;AACA,QAAMC,+BAA+BH,aAAaI,MAAb,CAAoBC,eAAeA,YAAYC,MAAZ,GAAqB,CAAxD,CAArC;AACAjE,SAAOyD,KAAP,CAAajG,QAAQsG,4BAAR,EAAsC,EAACD,OAAO,CAAR,EAAtC,CAAb;AACA;AACA,SAAOC,6BAA6BG,MAA7B,KAAwC5E,aAAa6E,oBAA5D;AACD;;AAED,SAASzD,8CAAT,CAAyDP,QAAzD,EAAkF;AAChFF,SAAOyD,KAAP,CAAa,mEAAb;AACA,QAAMU,aAAajE,SAAS2C,oBAAT,EAAnB;;AAEA;AACA;AACA,QAAMuB,mBAAmBrB,OAAOC,IAAP,CAAYmB,WAAWrB,QAAX,EAAZ,EAAmCpD,GAAnC,CAAuC2E,YAAY;AAC1E,UAAMC,gBAAiB,MAAKD,SAAS,CAAT,EAAYE,WAAZ,EAA0B,GAAEF,SAASG,KAAT,CAAe,CAAf,CAAkB,EAA1E;AACA,UAAMC,eAAeN,WAAWG,aAAX,GAArB;AACA,QAAIG,aAAaR,MAAb,KAAwB,CAA5B,EAA+B;AAC7BjE,aAAOyD,KAAP,CAAc,kDAAiDY,QAAS,mBAAxE;AACA,aAAO,IAAP;AACD;;AAED;AACA;AACA;AACA;AACA,UAAMK,kBAAkB/G,IACtBE,OAAO,IAAP,CADsB,EAEtBD,SAAS,CAAT,EAAY6G,YAAZ,EAA0B/E,GAA1B,CAA8B,CAAC,CAAC2D,CAAD,EAAIC,CAAJ,CAAD,KAAYD,EAAEhD,SAAF,KAAgBiD,EAAEjD,SAAF,EAA1D,CAFsB,CAAxB;AAIAL,WAAOyD,KAAP,CAAc,kDAAiDY,QAAS,wBAAuBK,gBAAgBC,QAAhB,EAA2B,EAA1H;AACA,QAAI,CAACD,eAAL,EAAsB;AACpB1E,aAAOyD,KAAP,CAAc,kDAAiDjG,QAAQ2G,WAAWrB,QAAX,EAAR,CAA+B,EAA9F;AACD;AACD,WAAO4B,eAAP;AACD,GArBwB,CAAzB;;AAuBA;AACA1E,SAAOyD,KAAP,CAAc,wEAAuEjG,QAAQ4G,gBAAR,CAA0B,EAA/G;AACA,SAAOzG,IAAIE,OAAO,IAAP,CAAJ,EAAkBuG,gBAAlB,CAAP;AACD;;AAED,SAAS1D,8BAAT,CAAyCR,QAAzC,EAAkE;AAChEF,SAAOyD,KAAP,CAAa,mDAAb;AACA,QAAMmB,oBAAoB1E,SAAS2E,YAAT,EAA1B;;AAEA,QAAMC,sBAAsB/F,wBAAwBE,oBAAoBiB,SAAS2C,oBAAT,EAApB,CAAxB,CAA5B;AACA,QAAMkC,oBAAoBxG,SAASS,oBAAoB8F,mBAApB,EAAyCH,QAAzC,EAAT,CAA1B;AACA,SAAOC,sBAAsBG,iBAA7B;AACD;;AAED,SAASpE,oBAAT,CAA+BT,QAA/B,EAAwD;AACtDF,SAAOyD,KAAP,CAAa,yCAAb;AACA,SAAOV,OAAOC,IAAP,CAAY9C,SAAS4C,QAAT,EAAZ,EAAiCG,MAAjC,CAAwC,CAACtF,GAAD,EAAMqH,CAAN,KAAY;AACzD,QAAIrH,IAAIqH,CAAJ,MAAW5E,SAAX,IAAwBzC,IAAIqH,CAAJ,EAAOf,MAAP,GAAgB,GAA5C,EAAiD;AAC/CtG,YAAM,KAAN;AACD;AACD,WAAOA,GAAP;AACD,GALM,EAKJ,IALI,CAAP;AAMD;;AAED,SAASsH,kBAAT,CAA6B/E,QAA7B,EAAsD;AACpDF,SAAOyD,KAAP,CAAa,uCAAb;AACA,QAAMyB,sBAAsBhF,SAASgB,YAAT,KAA0B,IAAtD;AACA,QAAMiE,wBAAwBlG,oBAAoBiB,SAAS2C,oBAAT,EAApB,CAA9B;AACA,QAAMuC,uBAAuBD,sBAAsBzF,GAAtB,CAA0B6D,UAAU;AAC/D;AACA,WAAOA,OAAOrC,YAAP,MAAyBgE,sBAAsB1F,UAAU+D,OAAO8B,aAAP,EAAV,EAAkCtF,OAAlC,GAA4C,IAAlG;AACD,GAH4B,CAA7B;AAIAC,SAAOyD,KAAP,CAAc,yBAAwBjG,QAAQ4H,oBAAR,CAA8B,EAApE;;AAEA,QAAME,sBAAsBH,sBAAsBzF,GAAtB,CAA0B6D,UAAU;AAC9D,UAAM,EAAEzD,MAAF,KAAaN,UAAU+D,OAAO8B,aAAP,EAAV,CAAnB;AACA,WAAOvF,WAAW,CAAX,IAAgBoF,sBAAsB3B,OAAOrC,YAAP,KAAwBpB,SAAS,IAA9E;AACD,GAH2B,CAA5B;AAIAE,SAAOyD,KAAP,CAAc,wBAAuBjG,QAAQ8H,mBAAR,CAA6B,EAAlE;AACA,SAAO3H,IAAIE,OAAO,IAAP,CAAJ,EAAkBuH,oBAAlB,KAA2CzH,IAAIE,OAAO,IAAP,CAAJ,EAAkByH,mBAAlB,CAAlD;AACD;;AAED,SAAS1E,+BAAT,CAA0CV,QAA1C,EAAmE;AACjEF,SAAOyD,KAAP,CAAa,oDAAb;AACA,QAAM8B,qBAAqBrF,SAASsF,aAAT,EAA3B;;AAEA,QAAMC,cAAc1G,wBAAwBE,oBAAoBiB,SAAS2C,oBAAT,EAApB,CAAxB,CAApB;AACA,QAAM6C,qBAAqBxG,iBAAiBV,UAAU,CACpDiH,WADoD,EAEpDvF,SAASyF,UAAT,EAFoD,EAGpD,CACEzF,SAAS0F,aAAT,EADF,EAEE1F,SAAS2F,QAAT,EAFF,EAGE3F,SAASG,SAAT,EAHF,EAIEH,SAAS4F,UAAT,EAJF,EAKE5F,SAAS6F,gBAAT,EALF,EAME7F,SAAS8F,WAAT,EANF,EAOE3G,aAAa4G,0BAPf,CAHoD,CAAV,CAAjB,CAA3B;;AAcA,SAAOV,uBAAuBG,kBAA9B;AACD;;AAED,SAAS7E,yBAAT,CAAoCX,QAApC,EAA6D;AAC3DF,SAAOyD,KAAP,CAAa,kDAAb;AACA,QAAMyC,mBAAmBhG,SAASiG,WAAT,EAAzB;AACA,QAAMC,qBAAqBlG,SAAS0F,aAAT,EAA3B,CAH2D,CAGP;AACrD5F,SAAOyD,KAAP,CAAa,sBAAsByC,gBAAnC;AACAlG,SAAOyD,KAAP,CAAa,wBAAwB2C,kBAArC;;AAEC,SAAO,IAAI1I,EAAJ,CAAOwI,gBAAP,EAAyBnE,EAAzB,CAA4B,IAAIrE,EAAJ,CAAO0I,kBAAP,CAA5B,CAAP;AACD;;AAED,SAAStF,6BAAT,CAAwCZ,QAAxC,EAAiE;AAC/DF,SAAOyD,KAAP,CAAa,kDAAb;AACA,QAAMyC,mBAAmBhG,SAASiG,WAAT,EAAzB;;AAEA,QAAME,eAAelH,YAAYe,SAASoG,eAAT,EAAZ,EAAwCpG,SAAS2C,oBAAT,EAAxC,CAArB;AACA,QAAM0D,mBAAmBnH,SACvBiH,YADuB,EAEvB9H,SACE2B,SAAS2F,QAAT,KACA3F,SAASsF,aAAT,EADA,GAEAjH,SAAS2B,SAASsG,QAAT,EAAT,CAFA,GAGAtG,SAASgB,YAAT,EAJF,CAFuB,EAQvByD,QARuB,EAAzB;AASA,SAAOuB,qBAAqBK,gBAA5B;AACD;;AAEM,SAAStJ,yBAAT,CAAoCwJ,eAApC,EAAiFC,gBAAjF,EAA+HC,KAA/H,EAA+I;AACpJ,QAAMC,mBAAmB5I,KAAKyI,eAAL,CAAzB;AACA,QAAMI,mBAAmB3I,KAAKwI,gBAAL,CAAzB;;AAEA;AACA,MAAI,CAACE,gBAAD,IAAqB,CAACC,gBAA1B,EAA4C;AAC1C,UAAMC,WAAWF,oBAAoBC,gBAArC;AACA,QAAIC,QAAJ,EAAc;AACZ9G,aAAOQ,IAAP,CAAa,iEAAgEsG,SAASzB,aAAT,EAAyB,EAAtG;AACD,KAFD,MAEO;AACLrF,aAAOQ,IAAP,CAAa,6DAAb;AACD;AACD,WAAO,KAAP;AACD;;AAED;AACA,MAAIuG,QAAQH,iBAAiBN,eAAjB,OAAuCO,iBAAiBxE,OAAjB,EAAvC,IACVuE,iBAAiBvE,OAAjB,OAA+BwE,iBAAiBxE,OAAjB,EADjC;;AAGA,MAAI,CAAC0E,KAAL,EAAY;AACV/G,WAAOyD,KAAP,CAAc,WAAUmD,iBAAiBvB,aAAjB,EAAiC,wBAAuB7H,QAAQoJ,iBAAiB9D,QAAjB,EAAR,CAAqC,yCAAwCtF,QAAQqJ,iBAAiB/D,QAAjB,EAAR,CAAqC,EAAlM;AACA;AACD;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAI4D,iBAAiBzC,MAAjB,GAA0B,CAA9B,EAAiC;AAC/B8C,YAAQnJ,SAAS,CAAT,EAAY8I,gBAAZ,EAA8BzD,MAA9B,CAAqC,CAAC+D,MAAD,EAAS,CAAC3D,CAAD,EAAIC,CAAJ,CAAT,KAAoBD,EAAEhB,OAAF,OAAgBiB,EAAEgD,eAAF,EAAhB,IAAuCU,MAAhG,EAAwG,IAAxG,CAAR;;AAEA,QAAI,CAACD,KAAL,EAAY;AACV/G,aAAOyD,KAAP,CAAc,oCAAd;AACA;AACD;AACF;;AAED,SAAO,IAAP;AACD;;AAEM,SAASvG,wBAAT,CAAmC+J,MAAnC,EAA+D;AACpE,QAAMC,eAAe9I,KAAK,CAACiF,CAAD,EAAIC,CAAJ,KAAUA,EAAEjD,SAAF,KAAgBgD,EAAEhD,SAAF,EAA/B,EAA8C4G,MAA9C,CAArB;AACA,QAAME,SAASvJ,SAAS,CAAT,EAAYsJ,YAAZ,EAA0BxH,GAA1B,CAA8B,CAAC,CAAC0H,KAAD,EAAQC,MAAR,CAAD,KAAqB;AAChE,WAAOA,OAAOhH,SAAP,OAAuBhB,aAAaiI,MAApC,IAA8CC,6BAA6BH,KAA7B,EAAoCC,MAApC,CAArD;AACD,GAFc,CAAf;;AAIArH,SAAOyD,KAAP,CAAc,6BAA4BjG,QAAQ2J,MAAR,CAAgB,EAA1D;;AAEA,SAAOxJ,IAAIE,OAAO,IAAP,CAAJ,EAAkBC,QAAQqJ,MAAR,CAAlB,CAAP;AACD;;AAEM,SAAShK,6BAAT,CAAwCqK,aAAxC,EAAgEtH,QAAhE,EAA4F;AACjGF,SAAOgB,IAAP,CAAY,4CAA4CwG,cAAcnH,SAAd,EAA5C,GAAwE,mBAAxE,GAA8FH,SAASG,SAAT,EAA1G;;AAGA,QAAMoH,cAAc,IAAI/J,EAAJ,CAAO8J,cAAcrB,WAAd,EAAP,EAAoCrE,GAApC,CAAwC,IAAIpE,EAAJ,CAAO8J,cAAc5B,aAAd,EAAP,CAAxC,EAA+E8B,QAA/E,CAAwF,IAAIhK,EAAJ,CAAO,CAAP,CAAxF,EAAmGiH,QAAnG,EAApB;AACO;;AAEP;AACA,QAAMgD,gBAAgB,IAAIjK,EAAJ,CAAO8J,cAAcI,gBAAd,EAAP,EAAyCjG,GAAzC,CAA6C,IAAIjE,EAAJ,CAAO+J,WAAP,CAA7C,EAAkE9F,GAAlE,CAAsE,IAAIjE,EAAJ,CAAOwC,SAAS0F,aAAT,EAAP,CAAtE,EAAwGjB,QAAxG,EAAtB;;AAEA3E,SAAOgB,IAAP,CAAY,qCAAqCwG,cAAcnH,SAAd,EAArC,GAAiE,KAAjE,GAAyEH,SAASG,SAAT,EAAzE,GAAgG,MAAhG,GAAyGoH,WAArH;AACAzH,SAAOgB,IAAP,CAAY,6BAA6B2G,aAAzC;AACA3H,SAAOgB,IAAP,CAAY,oCAAoCd,SAAS0H,gBAAT,EAAhD;;AAEA,MAAGJ,cAAc5B,aAAd,OAAkC,EAAlC,IAAwC4B,cAAc5B,aAAd,KAAgC,CAA3E,EAA6E;AAC3E,WAAO,IAAP;AACD;AACD,SAAO+B,kBAAkBzH,SAAS0H,gBAAT,EAAzB;AACD;;AAEM,SAASxK,0BAAT,CAAqCoK,aAArC,EAA6DtH,QAA7D,EAAyF;AAC9FF,SAAOgB,IAAP,CAAY,uCAAuCwG,cAAcnH,SAAd,EAAvC,GAAmE,mBAAnE,GAAyFH,SAASG,SAAT,EAArG;AACA,QAAMwH,gBAAgBhJ,iBAAiB2I,cAAc3E,oBAAd,EAAjB,EAAuD3C,SAAS2C,oBAAT,EAAvD,CAAtB;AACA,QAAMiF,aAAahJ,QACjBoB,SAASgB,YAAT,EADiB,EAEjBsG,cAActG,YAAd,EAFiB,EAGjBsG,cAAc5B,aAAd,EAHiB,EAIjBrG,kBAJiB,EAKjBsI,aALiB,EAMjB7K,gBAAgBkD,QAAhB,CANiB,CAAnB;;AASAF,SAAOgB,IAAP,CAAY,iBAAiB8G,UAA7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAMC,kBAAkBnJ,iBAAiBkJ,UAAjB,EAA6BN,cAAcnH,SAAd,EAA7B,EAAwDsE,QAAxD,EAAxB;;AAEA3E,SAAOgB,IAAP,CAAY,uCAAuCwG,cAAcnH,SAAd,EAAvC,GAAmE,IAAnE,GAA2EmH,cAAc5B,aAAd,EAA3E,GAA2G,oBAA3G,GAAkI1F,SAASG,SAAT,EAAlI,GAAyJ,IAAzJ,GAAgKH,SAAS0F,aAAT,EAAhK,GAA2L,IAAvM;AACA5F,SAAOgB,IAAP,CAAY,0BAA0B+G,eAAtC;;AAEA;AACA;AACA;AACA;AACA,SAAO7H,SAAS0F,aAAT,OAA6BmC,eAApC;AACD;;AAED,SAASR,4BAAT,CAAuCS,UAAvC,EAAmDC,WAAnD,EAAwE;AACtE,QAAMC,yBAAyBF,WAAWnF,oBAAX,EAA/B;AACA,QAAMsF,0BAA0BF,YAAYpF,oBAAZ,EAAhC;AACA;AACA,SAAO,CACL5F,0BAA0BiL,uBAAuBE,UAAvB,EAA1B,EAA+DD,wBAAwBC,UAAxB,EAA/D,CADK,EAELnL,0BAA0BiL,uBAAuBG,UAAvB,EAA1B,EAA+DF,wBAAwBE,UAAxB,EAA/D,CAFK,EAGLpL,0BAA0BiL,uBAAuBI,UAAvB,EAA1B,EAA+DH,wBAAwBG,UAAxB,EAA/D,CAHK,EAILrL,0BAA0BiL,uBAAuBK,UAAvB,EAA1B,EAA+DJ,wBAAwBI,UAAxB,EAA/D,CAJK,EAKLtL,0BAA0BiL,uBAAuBM,UAAvB,EAA1B,EAA+DL,wBAAwBK,UAAxB,EAA/D,CALK,CAAP;AAOD;;AAEM,SAASnL,qBAAT,CAAgC4J,MAAhC,EAAyD;AAC9D;AACA,MAAI9I,OAAOF,QAAP,EAAiBgJ,MAAjB,EAAyBhD,MAAzB,GAAkC,CAAtC,EAAyC;AACvCjE,WAAOyD,KAAP,CAAa,0BAAb;AACA,WAAO,KAAP;AACD;AACD;AACA,QAAMyD,eAAe9I,KAAK,CAACiF,CAAD,EAAIC,CAAJ,KAAUA,EAAEjD,SAAF,KAAgBgD,EAAEhD,SAAF,EAA/B,EAA8C4G,MAA9C,CAArB;AACA,QAAMwB,sBAAsBrK,KAAK,CAACiF,CAAD,EAAIC,CAAJ,KAAUD,EAAEhD,SAAF,KAAgBiD,EAAEjD,SAAF,EAA/B,EAA8C4G,MAA9C,CAA5B;;AAEAjH,SAAOyD,KAAP,CAAc,uCAAsCyD,aAAaxH,GAAb,CAAiB4D,KAAKA,EAAEjD,SAAF,EAAtB,EAAqCsE,QAArC,EAAgD,EAApG;AACA;AACA,QAAM+D,aAAa9K,SAAS,CAAT,EAAYsJ,YAAZ,EAA0BxH,GAA1B,CAA8B,CAAC,CAAC2D,CAAD,EAAIC,CAAJ,CAAD,KAAY;AAC3D,WAAOD,EAAEiD,eAAF,OAAwBhD,EAAEjB,OAAF,EAA/B;AACD,GAFkB,CAAnB;;AAIArC,SAAOyD,KAAP,CAAc,uCAAsCjG,QAAQI,SAAS,CAAT,EAAYsJ,aAAaxH,GAAb,CAAiB4D,KAAKA,EAAEjD,SAAF,EAAtB,CAAZ,CAAR,CAA2D,EAA/G;AACA,MAAI,CAAC1C,IAAIE,OAAO,IAAP,CAAJ,EAAkB6K,UAAlB,CAAL,EAAoC;AAClC1I,WAAOyD,KAAP,CAAc,qCAAoCiF,UAAW,EAA7D;AACA,WAAO,KAAP;AACD;;AAED;AACA,QAAMC,oBAAoB/K,SAAS,CAAT,EAAY6K,mBAAZ,EAAiC/I,GAAjC,CAAqC,CAAC,CAAC2D,CAAD,EAAIC,CAAJ,CAAD,KAAY;AACzE,WAAOlG,2BAA2BiG,CAA3B,EAA8BC,CAA9B,CAAP;AACD,GAFyB,CAA1B;;AAIAtD,SAAOyD,KAAP,CAAc,uCAAsCjG,QAAQI,SAAS,CAAT,EAAYsJ,aAAaxH,GAAb,CAAiB4D,KAAKA,EAAEjD,SAAF,EAAtB,CAAZ,CAAR,CAA2D,EAA/G;AACA,MAAI,CAAC1C,IAAIE,OAAO,IAAP,CAAJ,EAAkB8K,iBAAlB,CAAL,EAA2C;AACzC3I,WAAOyD,KAAP,CAAa,4CAAb;AACA;AACD;AACD;AACA;AACA,QAAMmF,QAAQhL,SAAS,CAAT,EAAYsJ,YAAZ,CAAd;AACA,QAAM2B,UAAUD,MAAMlJ,GAAN,CAAW2D,CAAD,IAAO;AAC/BrD,WAAOyD,KAAP,CAAaJ,CAAb;AACA,WAAO,CAACA,EAAE,CAAF,EAAKhD,SAAL,EAAD,EAAmBgD,EAAE,CAAF,EAAKhD,SAAL,EAAnB,CAAP;AACD,GAHe,CAAhB;AAIAL,SAAOyD,KAAP,CAAa,kCAAkCqF,KAAKC,SAAL,CAAeF,OAAf,EAAwB,IAAxB,EAA8B,CAA9B,CAA/C;AACA;AACA;AACA;AACA,QAAMG,qBAAqBJ,MAAMlJ,GAAN,CAAU,CAAC,CAAC0H,KAAD,EAAQC,MAAR,CAAD,KAAqB;AACxD,WAAOA,OAAOhH,SAAP,OAAuBhB,aAAaiI,MAApC,IAA8CC,6BAA6BH,KAA7B,EAAoCC,MAApC,CAArD;AACD,GAF0B,CAA3B;AAGA;AACArH,SAAOyD,KAAP,CAAc,4CAA2CjG,QAAQwL,kBAAR,CAA4B,EAArF;AACA,MAAI,CAACrL,IAAIE,OAAO,IAAP,CAAJ,EAAkBC,QAAQkL,kBAAR,CAAlB,CAAL,EAAqD;AACnDhJ,WAAOyD,KAAP,CAAa,uBAAb;AACA;AACD;;AAED,SAAO,IAAP;AACD;;AAEM,SAASnG,oBAAT,CAA+BqJ,KAA/B,EAAuD;;AAE5D,QAAMsC,UAAUlG,OAAOa,MAAP,CAAc+C,MAAM9D,oBAAN,GAA6BC,QAA7B,EAAd,EAAuDG,MAAvD,CAA8D,CAACtF,GAAD,EAAMiF,OAAN,KAAkB;AAChG,UAAMsG,MAAMtG,QAAQxE,IAAR,CAAa,CAACiF,CAAD,EAAIC,CAAJ,KAAU;AAClC,UAAGD,EAAEiE,MAAF,GAAWhE,EAAEgE,MAAhB,EAAwB;AACvB,eAAO,CAAP;AACA;AACD,UAAGjE,EAAEiE,MAAF,GAAWhE,EAAEgE,MAAhB,EAAwB;AACvB,eAAO,CAAC,CAAR;AACA;AACD,aAAO,CAAP;AACC,KARU,EAQR9D,GARQ,EAAZ;AASE,QAAG0F,QAAQ9I,SAAX,EAAsB;AACtBzC,UAAIuL,IAAI1H,UAAR,IAAsB0H,GAAtB;AACC;AACF,WAAOvL,GAAP;AACD,GAdgB,EAcd,EAdc,CAAhB;;AAgBA,QAAMwL,MAAMpG,OAAOa,MAAP,CAAcqF,OAAd,CAAZ;;AAEA,MAAGE,IAAIlF,MAAJ,GAAa,CAAhB,EAAkB;AAChB,WAAO,CAAC,CAAD,CAAP;AACD,GAFD,MAEO;AACL,WAAOkF,GAAP;AACD;AACF;;AAEM,SAAS5L,iBAAT,CAA4BoJ,KAA5B,EAAoD;AACzD,SAAOtI,IACHf,qBAAqBqJ,KAArB,EAA4BjH,GAA5B,CAAiC6D,MAAD,IAAY6F,OAAO7F,OAAO+D,MAAd,CAA5C,CADG,CAAP;AAGD","file":"validation.js","sourcesContent":["/**\n * Copyright (c) 2017-present, Block Collider developers, All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n */\n/* eslint-disable */\nconst { inspect } = require('util')\nconst BN = require('bn.js')\nconst {\n  all,\n  aperture,\n  equals,\n  flatten,\n  fromPairs,\n  head,\n  identity,\n  last,\n  reject,\n  sort,\n  sum\n} = require('ramda')\n\nconst { getLogger } = require('../logger')\nconst { blake2bl } = require('../utils/crypto')\nconst { concatAll } = require('../utils/ramda')\nconst { BcBlock, BlockchainHeader, Block } = require('../protos/core_pb')\nconst {\n  getExpFactorDiff,\n  getNewBlockCount,\n  getDiff,\n  getChildrenBlocksHashes,\n  getChildrenRootHash,\n  blockchainMapToList,\n  createMerkleRoot,\n  prepareWork,\n  distance\n} = require('../mining/primitives')\nconst GENESIS_DATA = require('./genesis.raw')\nconst FINGERPRINTS_TEMPLATE = require('../utils/templates/blockchain_fingerprints.json')\nconst MINIMAL_DIFFICULTY = new BN(290112262029012)\n\nexport type DfConfig = {\n  [chain: string]: {dfNumerator: number, dfDenominator: number, dfVoid: number, dfBound: number}\n}\nexport const DF_CONFIG: DfConfig = fromPairs(FINGERPRINTS_TEMPLATE.blockchainHeaders.map(\n  ({name, dfNumerator, dfDenominator, dfVoid, dfBound}) => ([name, {dfNumerator, dfDenominator, dfVoid, dfBound}])\n))\n\nconst logger = getLogger(__filename)\n\nexport function isValidBlock (newBlock: BcBlock, type: number = 0): bool {\n  if (newBlock === undefined) {\n    return false\n  }\n  if (new BN(newBlock.getHeight()).lt(new BN(151500)) === true) {\n    return true\n  }\n  // if (!theBlockChainFingerPrintMatchGenesisBlock(newBlock)) {\n  //  logger.warn('failed: theBlockChainFingerPrintMatchGenesisBlock')\n  //  return false\n  // } // DISABLED UNTIL AT\n  if (!numberOfBlockchainsNeededMatchesChildBlock(newBlock)) {\n    logger.warn('failed: numberOfBlockchainsNeededMatchesChildBlock')\n    return false\n  }\n  if (!ifMoreThanOneHeaderPerBlockchainAreTheyOrdered(newBlock)) {\n    logger.warn('failed: ifMoreThanOneHeaderPerBlockchainAreTheyOrdered')\n    return false\n  }\n  if (!isChainRootCorrectlyCalculated(newBlock)) {\n    logger.warn('failed: isChainRootCorrectlyCalculated')\n    return false\n  }\n  if (!isFieldLengthBounded(newBlock)) {\n    logger.warn('failed: isFieldLengthBounded')\n    return false\n  }\n  if (!isMerkleRootCorrectlyCalculated(newBlock)) {\n    logger.warn('failed: isMerkleRootCorrectlyCalculated')\n    return false\n  }\n  if (!isValidChildAge(newBlock)) {\n    return false\n  }\n  if (!isDistanceAboveDifficulty(newBlock)) {\n    logger.warn('failed: isDistanceAboveDifficulty')\n    return false\n  }\n  if (!isDistanceCorrectlyCalculated(newBlock)) {\n    logger.warn('failed: isDistanceCorrectlyCalculated')\n    return false\n  }\n  if (type === 0) {\n    //if (!areDarkFibersValid(newBlock)) {\n    //  logger.warn('failed: areDarkFibersValid')\n    //  return false\n    //}\n  }\n  return true\n}\n\nexport function isValidChildAge (newBlock: BcBlock, type: number = 0): bool {\n  const newestHeader = getNewestHeader(newBlock)\n\n  logger.info('confirming valid child ages for new block')\n  if (newestHeader === false) {\n    logger.warn('failed: validChildAge no upper limit child header found')\n    return false\n  }\n\n  // add the offset for dark fiber\n  const bcBlockTimestamp = new BN(newBlock.getTimestamp()).mul(new BN(1000)).toNumber()\n  const highRangeLimit = 59 * 1000\n  const lowRangeLimit = 29 * 1000\n  const newestHeaderDFBound = DF_CONFIG[newestHeader.blockchain].dfBound * 1000\n  const newestHeaderTimestamp = new BN(newestHeader.timestamp).add(new BN(newestHeaderDFBound)).toNumber()\n  const upperTimestampLimit = new BN(newestHeaderTimestamp).add(new BN(highRangeLimit)).toNumber()\n  const lowerTimestampLimit = new BN(newestHeaderTimestamp).sub(new BN(lowRangeLimit)).toNumber()\n\n  logger.info('bcblocktimestamp timestamp: ' + bcBlockTimestamp)\n  logger.info('newest header bound: ' + newestHeaderDFBound)\n  logger.info('newest header timestamp: ' + newestHeader.timestamp)\n  logger.info('upperTimestampLimit: ' + upperTimestampLimit)\n  logger.info('lowerTimestampLimit: ' + lowerTimestampLimit)\n\n  /* eslint-enable */\n  if (new BN(bcBlockTimestamp).gt(new BN(upperTimestampLimit)) === true) {\n    logger.warn('failed: isValidChildAge upper limit')\n    return false\n  }\n\n  if (new BN(bcBlockTimestamp).lt(new BN(lowerTimestampLimit)) === true) {\n    logger.warn('failed: isValidChildAge lower limit')\n    return false\n  }\n  return true\n}\n\nexport async function isValidBlockCached (persistence: Object, newBlock: BcBlock, type: number = 0): Promise<boolean> {\n  try {\n    if (new BN(newBlock.getHeight()).lt(new BN(151500)) === true) {\n      return Promise.resolve(true)\n    }\n    const cached = await persistence.get('valid_' + newBlock.getHash())\n    // if of type: string 'false' it means the block is invalid\n    return Promise.resolve(cached === 'true')\n  } catch (_) {\n    try {\n      const valid = isValidBlock(newBlock, type)\n      await persistence.put('valid_' + newBlock.getHash(), String(valid))\n      // return this block in wrhatever state it was validated\n      return Promise.resolve(valid)\n    } catch (err) {\n      // error attempting to parse this as a block, reject\n      logger.error(err)\n      return Promise.resolve(false)\n    }\n  }\n}\n\nexport function getNewestHeader (newBlock: BcBlock): bool {\n  logger.info('getting block height ' + newBlock.getHeight())\n  if (newBlock === undefined) {\n    logger.warn('failed: isValidChildAge new block could not be found')\n    return false\n  }\n\n  const headers = newBlock.getBlockchainHeaders().toObject()\n  const newestHeader = Object.keys(headers).reduce((newest, key) => {\n    const sorted = headers[key].sort((a, b) => {\n      /* eslint-disable */\n      if (new BN(a.timestamp).gt(new BN(b.timestamp)) === true) {\n        return 1\n      }\n      if (new BN(a.timestamp).lt(new BN(b.timestamp)) === true) {\n        return -1\n      }\n      return 0\n    })\n\n    const header = sorted.pop()\n\n    if (newest === false) {\n      newest = header\n    } else {\n      if (new BN(newest.timestamp).lt(new BN(header.timestamp))) {\n        newest = header\n      }\n    }\n    return newest\n  }, false)\n\n  if (newestHeader === false) {\n    return false\n  }\n\n  return newestHeader\n}\n\n// function theBlockChainFingerPrintMatchGenesisBlock (newBlock: BcBlock): bool {\n//  logger.info('theBlockChainFingerPrintMatchGenesisBlock validation running')\n//  return newBlock.getBlockchainFingerprintsRoot() === GENESIS_DATA.blockchainFingerprintsRoot\n// }\n\nfunction numberOfBlockchainsNeededMatchesChildBlock (newBlock: BcBlock): bool {\n  logger.debug('numberOfBlockchainsNeededMatchesChildBlock validation running')\n  // skip for genesis block - it chas no blockchain blocks embedded\n  if (newBlock.getHeight() === GENESIS_DATA.hash && newBlock.getHeight() === 1) {\n    return true\n  }\n  // verify that all blockain header lists are non empty and that there is childBlockchainCount of them\n  const headerValues = Object.values(newBlock.getBlockchainHeaders().toObject())\n  logger.debug(inspect(headerValues, {depth: 3}))\n  // $FlowFixMe\n  const headerValuesWithLengthGtZero = headerValues.filter(headersList => headersList.length > 0)\n  logger.debug(inspect(headerValuesWithLengthGtZero, {depth: 3}))\n  // logger.info(GENESIS_DATA.childBlockchainCount)\n  return headerValuesWithLengthGtZero.length === GENESIS_DATA.childBlockchainCount\n}\n\nfunction ifMoreThanOneHeaderPerBlockchainAreTheyOrdered (newBlock: BcBlock): bool {\n  logger.debug('ifMoreThanOneHeaderPerBlockchainAreTheyOrdered validation running')\n  const headersMap = newBlock.getBlockchainHeaders()\n\n  // gather true/false for each chain signalling if either there is only one header\n  // (most common case) or headers maintain ordering\n  const chainsConditions = Object.keys(headersMap.toObject()).map(listName => {\n    const getMethodName = `get${listName[0].toUpperCase()}${listName.slice(1)}`\n    const chainHeaders = headersMap[getMethodName]()\n    if (chainHeaders.length === 1) {\n      logger.debug(`ifMoreThanOneHeaderPerBlockchainAreTheyOrdered ${listName} single and valid`)\n      return true\n    }\n\n    // return true if left height < right height condition is valid\n    // for all pairs ([[a, b], [b, c], [c, d]]) of chain headers ([a, b, c, d])\n    // (in other words if ordering is maintained)\n    // TODO\n    const orderingCorrect = all(\n      equals(true),\n      aperture(2, chainHeaders).map(([a, b]) => a.getHeight() < b.getHeight())\n    )\n    logger.debug(`ifMoreThanOneHeaderPerBlockchainAreTheyOrdered ${listName} multiple and valid: ${orderingCorrect.toString()}`)\n    if (!orderingCorrect) {\n      logger.debug(`ifMoreThanOneHeaderPerBlockchainAreTheyOrdered ${inspect(headersMap.toObject())}`)\n    }\n    return orderingCorrect\n  })\n\n  // check if all chain conditions are true\n  logger.debug(`ifMoreThanOneHeaderPerBlockchainAreTheyOrdered all chain conditions: ${inspect(chainsConditions)}`)\n  return all(equals(true), chainsConditions)\n}\n\nfunction isChainRootCorrectlyCalculated (newBlock: BcBlock): bool {\n  logger.debug('isChainRootCorrectlyCalculated validation running')\n  const receivedChainRoot = newBlock.getChainRoot()\n\n  const expectedBlockHashes = getChildrenBlocksHashes(blockchainMapToList(newBlock.getBlockchainHeaders()))\n  const expectedChainRoot = blake2bl(getChildrenRootHash(expectedBlockHashes).toString())\n  return receivedChainRoot === expectedChainRoot\n}\n\nfunction isFieldLengthBounded (newBlock: BcBlock): bool {\n  logger.debug('isFieldLengthBounded validation running')\n  return Object.keys(newBlock.toObject()).reduce((all, k) => {\n    if (all[k] !== undefined && all[k].length > 128) {\n      all = false\n    }\n    return all\n  }, true)\n}\n\nfunction areDarkFibersValid (newBlock: BcBlock): bool {\n  logger.debug('areDarkFibersValid validation running')\n  const newBlockTimestampMs = newBlock.getTimestamp() * 1000\n  const blockchainHeadersList = blockchainMapToList(newBlock.getBlockchainHeaders())\n  const dfBoundHeadersChecks = blockchainHeadersList.map(header => {\n    // e.g. NEO 1000 (rovered ts)  <=    1400 (mined time) -   300 (dfBound for NEO)\n    return header.getTimestamp() <= newBlockTimestampMs - DF_CONFIG[header.getBlockchain()].dfBound * 1000\n  })\n  logger.debug(`dfBoundHeadersChecks: ${inspect(dfBoundHeadersChecks)}`)\n\n  const dfVoidHeadersChecks = blockchainHeadersList.map(header => {\n    const { dfVoid } = DF_CONFIG[header.getBlockchain()]\n    return dfVoid === 0 || newBlockTimestampMs < header.getTimestamp() + dfVoid * 1000\n  })\n  logger.debug(`dfVoidHeadersChecks: ${inspect(dfVoidHeadersChecks)}`)\n  return all(equals(true), dfBoundHeadersChecks) && all(equals(true), dfVoidHeadersChecks)\n}\n\nfunction isMerkleRootCorrectlyCalculated (newBlock: BcBlock): bool {\n  logger.debug('isMerkleRootCorrectlyCalculated validation running')\n  const receivedMerkleRoot = newBlock.getMerkleRoot()\n\n  const blockHashes = getChildrenBlocksHashes(blockchainMapToList(newBlock.getBlockchainHeaders()))\n  const expectedMerkleRoot = createMerkleRoot(concatAll([\n    blockHashes,\n    newBlock.getTxsList(),\n    [\n      newBlock.getDifficulty(),\n      newBlock.getMiner(),\n      newBlock.getHeight(),\n      newBlock.getVersion(),\n      newBlock.getSchemaVersion(),\n      newBlock.getNrgGrant(),\n      GENESIS_DATA.blockchainFingerprintsRoot\n    ]\n  ]))\n\n  return receivedMerkleRoot === expectedMerkleRoot\n}\n\nfunction isDistanceAboveDifficulty (newBlock: BcBlock): bool {\n  logger.debug('isDistanceCorrectlyCalculated validation running')\n  const receivedDistance = newBlock.getDistance()\n  const recievedDifficulty = newBlock.getDifficulty() // !! NOTE: This is the difficulty for THIS block and not for the parent.\n\tlogger.debug('receivedDistance ' + receivedDistance)\n\tlogger.debug('receivedDifficulty ' + recievedDifficulty)\n\n  return new BN(receivedDistance).gt(new BN(recievedDifficulty))\n}\n\nfunction isDistanceCorrectlyCalculated (newBlock: BcBlock): bool {\n  logger.debug('isDistanceCorrectlyCalculated validation running')\n  const receivedDistance = newBlock.getDistance()\n\n  const expectedWork = prepareWork(newBlock.getPreviousHash(), newBlock.getBlockchainHeaders())\n  const expectedDistance = distance(\n    expectedWork,\n    blake2bl(\n      newBlock.getMiner() +\n      newBlock.getMerkleRoot() +\n      blake2bl(newBlock.getNonce()) +\n      newBlock.getTimestamp()\n    )\n  ).toString()\n  return receivedDistance === expectedDistance\n}\n\nexport function blockchainHeadersAreChain (childHeaderList: BlockchainHeader[]|Block[], parentHeaderList: BlockchainHeader[]|Block[], block: BcBlock) {\n  const firstChildHeader = head(childHeaderList)\n  const lastParentHeader = last(parentHeaderList)\n\n  // check if both parent and child have at least one header\n  if (!firstChildHeader || !lastParentHeader) {\n    const nonEmpty = firstChildHeader || lastParentHeader\n    if (nonEmpty) {\n      logger.warn(`first child header or last parent header were empty for chain ${nonEmpty.getBlockchain()}`)\n    } else {\n      logger.warn(`both first child header and last parent header were missing`)\n    }\n    return false\n  }\n\n  // check if either the header is the same one or first child header is actual child of last parent header\n  let check = firstChildHeader.getPreviousHash() === lastParentHeader.getHash() ||\n    firstChildHeader.getHash() === lastParentHeader.getHash()\n\n  if (!check) {\n    logger.debug(`chain: \"${firstChildHeader.getBlockchain()}\" first child header ${inspect(firstChildHeader.toObject())} is not a child of last parent header ${inspect(lastParentHeader.toObject())}`)\n    // return check // Disabled until AT\n  }\n\n  // if more than one child header check if child headers form a chain\n  // if (childHeaderList.length > 1) {\n  //  check = aperture(2, childHeaderList).reduce((result, [a, b]) => a.getHash() === b.getPreviousHash() && result, true)\n\n  //  if (!check) {\n  //    logger.info(`child headers do not form a chain`)\n  //    // return check // Disabled until AT\n  //  }\n  // }\n\n  // if more than one parent header check if parent headers form a chain\n  if (parentHeaderList.length > 1) {\n    check = aperture(2, parentHeaderList).reduce((result, [a, b]) => a.getHash() === b.getPreviousHash() && result, true)\n\n    if (!check) {\n      logger.debug(`parent headers do not form a chain`)\n      // return check // Disabled until AT\n    }\n  }\n\n  return true\n}\n\nexport function validateRoveredSequences (blocks: BcBlock[]): boolean {\n  const sortedBlocks = sort((a, b) => b.getHeight() - a.getHeight(), blocks)\n  const checks = aperture(2, sortedBlocks).map(([child, parent]) => {\n    return parent.getHeight() === GENESIS_DATA.height || validateChildHeadersSequence(child, parent)\n  })\n\n  logger.debug(`validateRoveredSequences: ${inspect(checks)}`)\n\n  return all(equals(true), flatten(checks))\n}\n\nexport function validateSequenceTotalDistance (previousBlock: BcBlock, newBlock: BcBlock): boolean {\n  logger.info('comparing totalDifficulties prevBlock: ' + previousBlock.getHeight() + ' with next block ' + newBlock.getHeight())\n\n\n  const chainWeight = new BN(previousBlock.getDistance()).sub(new BN(previousBlock.getDifficulty())).divRound(new BN(8)).toString()\n         //chainWeight = new BN(lastPreviousBlock.getDistance()).sub(new BN(previousBlock.getDifficulty())).divRound(new BN(8)).toString()\n\n  // unfinishedBlock.setTotalDistance(new BN(unfinishedBlock.getTotalDistance()).add(new BN(chainWeight)).add(new BN(unfinishedBlock.getDifficulty(), 10)).toString())\n  const finalDistance = new BN(previousBlock.getTotalDistance()).add(new BN(chainWeight)).add(new BN(newBlock.getDifficulty())).toString()\n\n  logger.info('chain weight between prevBlock: ' + previousBlock.getHeight() + ' - ' + newBlock.getHeight() + ' is ' + chainWeight)\n  logger.info('final total distance is ' + finalDistance)\n  logger.info('final total distance should be ' + newBlock.getTotalDistance())\n\n  if(previousBlock.getDifficulty() === \"\" || previousBlock.getDifficulty() < 1){\n    return true\n  }\n  return finalDistance === newBlock.getTotalDistance()\n}\n\nexport function validateSequenceDifficulty (previousBlock: BcBlock, newBlock: BcBlock): boolean {\n  logger.info('comparing difficulties prevBlock: ' + previousBlock.getHeight() + ' with next block ' + newBlock.getHeight())\n  const newBlockCount = getNewBlockCount(previousBlock.getBlockchainHeaders(), newBlock.getBlockchainHeaders())\n  const preExpDiff = getDiff(\n    newBlock.getTimestamp(),\n    previousBlock.getTimestamp(),\n    previousBlock.getDifficulty(),\n    MINIMAL_DIFFICULTY,\n    newBlockCount,\n    getNewestHeader(newBlock)\n  )\n\n  logger.info('preExpDiff: ' + preExpDiff)\n\n  //const preExpDiff = getDiff(\n  //  currentTimestamp,\n  //  lastPreviousBlock.getTimestamp(),\n  //  lastPreviousBlock.getDifficulty(),\n  //  MINIMUM_DIFFICULTY,\n  //  newBlockCount,\n  //  getNewestHeader(lastPreviousBlock)\n  //) // Calculate the final pre-singularity difficulty adjustment\n\n  const finalDifficulty = getExpFactorDiff(preExpDiff, previousBlock.getHeight()).toString()\n\n  logger.info('comparing difficulties prevBlock: ' + previousBlock.getHeight() + ' (' +  previousBlock.getDifficulty() + ') with next block ' + newBlock.getHeight() + ' (' + newBlock.getDifficulty() + ') ')\n  logger.info('difficulty should be ' + finalDifficulty)\n\n  //if(previousBlock.getDifficulty() === \"\" || previousBlock.getDifficulty() < 1){\n  //  logger.warn('difficulty assertion overridden\n  //  return true\n  //}\n  return newBlock.getDifficulty() === finalDifficulty\n}\n\nfunction validateChildHeadersSequence (childBlock, parentBlock): bool[] {\n  const childBlockchainHeaders = childBlock.getBlockchainHeaders()\n  const parentBlockchainHeaders = parentBlock.getBlockchainHeaders()\n  // TODO this should be a map over all members of BlockchainHeaders instance to prevent error after adding another chain to Collider\n  return [\n    blockchainHeadersAreChain(childBlockchainHeaders.getBtcList(), parentBlockchainHeaders.getBtcList()),\n    blockchainHeadersAreChain(childBlockchainHeaders.getEthList(), parentBlockchainHeaders.getEthList()),\n    blockchainHeadersAreChain(childBlockchainHeaders.getLskList(), parentBlockchainHeaders.getLskList()),\n    blockchainHeadersAreChain(childBlockchainHeaders.getNeoList(), parentBlockchainHeaders.getNeoList()),\n    blockchainHeadersAreChain(childBlockchainHeaders.getWavList(), parentBlockchainHeaders.getWavList())\n  ]\n}\n\nexport function validateBlockSequence (blocks: BcBlock[]): bool {\n  // if any of the submissions are undefined reject the sequence\n  if (reject(identity, blocks).length > 0) {\n    logger.debug('undefined members in set')\n    return false\n  }\n  // BC: 10 > BC: 9 > BC: 8 ...\n  const sortedBlocks = sort((a, b) => b.getHeight() - a.getHeight(), blocks)\n  const sortedBlocksTopDown = sort((a, b) => a.getHeight() - b.getHeight(), blocks)\n\n  logger.debug(`validateBlockSequence sorted blocks ${sortedBlocks.map(b => b.getHeight()).toString()}`)\n  // validate that Bc blocks are all in the same chain\n  const validPairs = aperture(2, sortedBlocks).map(([a, b]) => {\n    return a.getPreviousHash() === b.getHash()\n  })\n\n  logger.debug(`validateBlockSequence sorted blocks ${inspect(aperture(2, sortedBlocks.map(b => b.getHeight())))}`)\n  if (!all(equals(true), validPairs)) {\n    logger.debug(`validateBlockSequence validPairs: ${validPairs}`)\n    return false\n  }\n\n  /* eslint-disable */\n  const validDifficulties = aperture(2, sortedBlocksTopDown).map(([a, b]) => {\n    return validateSequenceDifficulty(a, b)\n  })\n\n  logger.debug(`validateBlockSequence sorted blocks ${inspect(aperture(2, sortedBlocks.map(b => b.getHeight())))}`)\n  if (!all(equals(true), validDifficulties)) {\n    logger.debug('validateBlockSequence invalid Difficulties')\n    //return false\n  }\n  // validate that highest header from each blockchain list from each block maintains ordering\n  // [[BC10, BC9], [BC9, BC8]]\n  const pairs = aperture(2, sortedBlocks)\n  const heights = pairs.map((a) => {\n    logger.debug(a)\n    return [a[0].getHeight(), a[1].getHeight()]\n  })\n  logger.debug('pairs printed after this --> ' + JSON.stringify(heights, null, 2))\n  // now create:\n  // [[btcOrdered, ethOrdered, lskOrdered, neoOrdered, wavOrdered], [btcOrderder, ethOrdered, lskOrdered, neoOrdered, wavOrdered]]\n  //                                e.g. BC10, BC9\n  const validPairSubchains = pairs.map(([child, parent]) => {\n    return parent.getHeight() === GENESIS_DATA.height || validateChildHeadersSequence(child, parent)\n  })\n  // flatten => [btc10_9Ordered, eth10_9Ordered, lsk10_9Ordered, neo10_9Ordered, wav10_9Ordered, btc9_8Orderded, eth9_8Ordered, lsk9_8Ordered, neo9_8Ordered, wav9_8Ordered]\n  logger.debug(`validateBlockSequence validPairSubchains ${inspect(validPairSubchains)}`)\n  if (!all(equals(true), flatten(validPairSubchains))) {\n    logger.debug('failed test of rovers')\n    // return false // TODO: AT -> is enabled in validation\n  }\n\n  return true\n}\n\nexport function childrenHighestBlock (block: BcBlock): number {\n\n  const highest = Object.values(block.getBlockchainHeaders().toObject()).reduce((all, headers) => {\n\t\tconst top = headers.sort((a, b) => {\n\t\t\tif(a.height > b.height) {\n\t\t\t\treturn 1\n\t\t\t}\n\t\t\tif(a.height < b.height) {\n\t\t\t\treturn -1\n\t\t\t}\n\t\t\treturn 0\n\t  }).pop()\n    if(top !== undefined) {\n\t\t  all[top.blockchain] = top\n    }\n\t  return all\n\t}, {})\n\n  const set = Object.values(highest)\n\n  if(set.length < 1){\n    return [1]\n  } else {\n    return set\n  }\n}\n\nexport function childrenHeightSum (block: BcBlock): number {\n  return sum(\n      childrenHighestBlock(block).map((header) => Number(header.height))\n  )\n}\n"]}